<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>åœ°å›¾å®šä½å·¥å…·</title>
        <!-- å¼•å…¥Vue -->
        <script src="https://unpkg.com/vue@2/dist/vue.js"></script>
        <!-- å¼•å…¥Element UI -->
        <link rel="stylesheet" href="https://unpkg.com/element-ui/lib/theme-chalk/index.css" />
        <script src="https://unpkg.com/element-ui/lib/index.js"></script>
        <!-- å¼•å…¥Leaflet CSS -->
        <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
        <!-- å¼•å…¥Leaflet JS -->
        <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
        <!-- å¼•å…¥Three.js -->
        <script src="https://unpkg.com/three@0.138.0/build/three.min.js"></script>
        <!-- å¼•å…¥Turf.jsç”¨äºç²¾ç¡®çš„åœ°ç†è®¡ç®— -->
        <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
        <script>
            // ç¡®ä¿Three.jsåŠ è½½å®Œæˆåå†åŠ è½½å…¶ä»–æ¨¡å—
            window.addEventListener('load', function () {
                // åŠ¨æ€åŠ è½½GLTFLoader
                const script1 = document.createElement('script')
                script1.src = 'https://unpkg.com/three@0.138.0/examples/js/loaders/GLTFLoader.js'
                script1.onload = function () {
                    // GLTFLoaderåŠ è½½å®Œæˆ
                    console.log('GLTFLoader loaded')
                    // å°†GLTFLoaderæ·»åŠ åˆ°å…¨å±€å˜é‡
                    if (typeof THREE !== 'undefined' && window.GLTFLoader) {
                        THREE.GLTFLoader = window.GLTFLoader
                    }
                }
                document.head.appendChild(script1)

                // åŠ¨æ€åŠ è½½OrbitControls
                const script2 = document.createElement('script')
                script2.src = 'https://unpkg.com/three@0.138.0/examples/js/controls/OrbitControls.js'
                script2.onload = function () {
                    // OrbitControlsåŠ è½½å®Œæˆ
                    console.log('OrbitControls loaded')
                    // å°†OrbitControlsæ·»åŠ åˆ°å…¨å±€å˜é‡
                    if (typeof THREE !== 'undefined' && window.OrbitControls) {
                        THREE.OrbitControls = window.OrbitControls
                    }
                }
                document.head.appendChild(script2)
            })
        </script>
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: 'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei',
                    'å¾®è½¯é›…é»‘', Arial, sans-serif;
            }

            .container {
                position: relative;
                width: 100vw;
                height: 100vh;
            }

            .control-panel {
                position: absolute;
                top: 20px;
                left: 20px;
                z-index: 1000;
                background: white;
                padding: 20px;
                border-radius: 8px;
                box-shadow: 0 2px 12px 0 rgba(0, 0, 0, 0.1);
                min-width: 200px;
            }

            .control-panel .el-form-item {
                margin-bottom: 15px;
            }

            #map-container {
                width: 100%;
                height: 100%;
                position: relative;
                z-index: 1;
                pointer-events: auto;
            }

            .operate-group {
                display: flex;
                flex-direction: column;
                align-items: center;
            }

            .operate-group > button {
                width: 100%;
                margin-left: 0 !important;
            }

            .operate-group > button + button {
                margin-top: 12px;
            }

            .info-text {
                font-size: 12px;
                color: #909399;
                margin-top: 16px;
                line-height: 1.5;
            }

            .info-text > p {
                margin: 0;
                line-height: 1;
            }

            .info-text > p + p {
                margin-top: 12px;
            }

            /* Leafletåœ°å›¾æ ·å¼è¦†ç›– */
            .leaflet-container {
                font-family: inherit;
            }

            /* 3Dæ¨¡å‹å®¹å™¨ */
            #model-container {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                pointer-events: none;
                z-index: 500;
                background: transparent;
                user-select: none;
            }

            #model-container canvas {
                pointer-events: none;
                position: absolute;
                top: 0;
                left: 0;
                width: 100% !important;
                height: 100% !important;
                background: transparent !important;
                user-select: none;
            }

            .model-controls {
                position: absolute;
                top: 20px;
                right: 20px;
                z-index: 1000;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 12px 0 rgba(0, 0, 0, 0.1);
                min-width: 200px;
            }

            .model-controls > h4 {
                line-height: 1;
                margin-bottom: 15px;
                margin-block-start: 0;
                margin-block-end: 0;
            }

            /* ç¼©æ”¾çº§åˆ«æ§ä»¶æ ·å¼ */
            .leaflet-control-zoomlevel {
                margin-bottom: 10px;
            }

            .leaflet-control-zoomlevel > div {
                box-shadow: 0 1px 5px rgba(0, 0, 0, 0.4);
                background: white;
                border-radius: 4px;
                padding: 5px 10px;
                font-size: 12px;
                font-weight: bold;
                color: #333;
                min-width: 40px;
                text-align: center;
                border: 2px solid rgba(0, 0, 0, 0.2);
            }

            /* æµ‹è·ä¿¡æ¯æ ·å¼ */
            .distance-info {
                margin-top: 15px;
                padding: 10px;
                background: #f5f7fa;
                border-radius: 4px;
                border-left: 3px solid #409eff;
            }

            .distance-info p {
                margin: 5px 0;
                font-size: 12px;
                color: #606266;
            }

            .distance-info p:first-child {
                margin-top: 0;
            }

            .distance-info p:last-child {
                margin-bottom: 0;
            }

            /* æµ‹è·çº¿æ ·å¼ */
            .distance-line {
                stroke: #409eff;
                stroke-width: 3;
                stroke-dasharray: 5, 5;
                fill: none;
                opacity: 0.8;
            }

            .distance-point {
                fill: #409eff;
                stroke: white;
                stroke-width: 2;
                r: 6;
            }
        </style>
    </head>
    <body>
        <div id="app">
            <div class="container">
                <!-- æ§åˆ¶é¢æ¿ -->
                <div class="control-panel">
                    <el-form :model="form" label-width="60px" label-position="left" size="small">
                        <el-form-item label="ç»åº¦ï¼š">
                            <el-input
                                v-model="form.lng"
                                placeholder="è¯·è¾“å…¥ç»åº¦"
                                @keyup.enter.native="locateToCoordinates"
                            >
                            </el-input>
                        </el-form-item>
                        <el-form-item label="çº¬åº¦ï¼š">
                            <el-input
                                v-model="form.lat"
                                placeholder="è¯·è¾“å…¥çº¬åº¦"
                                @keyup.enter.native="locateToCoordinates"
                            >
                            </el-input>
                        </el-form-item>
                        <el-form-item label="åœ°å€ï¼š">
                            <el-input
                                v-model="form.address"
                                placeholder="è¯·è¾“å…¥åœ°å€è¿›è¡Œæœç´¢"
                                @keyup.enter.native="searchAddress"
                            >
                                <el-button
                                    slot="append"
                                    icon="el-icon-search"
                                    @click="searchAddress"
                                    :loading="addressLoading"
                                ></el-button>
                            </el-input>
                        </el-form-item>
                        <div class="operate-group">
                            <el-button type="primary" @click="locateToCoordinates" :loading="loading">
                                å®šä½åˆ°åæ ‡
                            </el-button>
                            <el-button type="success" @click="loadModelAtCurrentPosition" :loading="modelLoading">
                                åŠ è½½3Dæ¨¡å‹
                            </el-button>
                            <el-button
                                :type="isMeasuring ? 'danger' : 'warning'"
                                @click="toggleMeasuring"
                                :icon="isMeasuring ? 'el-icon-close' : 'el-icon-ruler'"
                            >
                                {{ isMeasuring ? 'ç»“æŸæµ‹è·' : 'å¼€å§‹æµ‹è·' }}
                            </el-button>
                            <el-button type="info" @click="createPolygon" :loading="polygonLoading">
                                åˆ›å»º188mx188måŒºåŸŸ
                            </el-button>
                        </div>
                        <!-- æµ‹è·ç»“æœæ˜¾ç¤º -->
                        <div v-if="isMeasuring || distancePoints.length > 0" class="distance-info">
                            <p><strong>æµ‹è·æ¨¡å¼</strong></p>
                            <p v-if="distancePoints.length === 0">ç‚¹å‡»åœ°å›¾å¼€å§‹æµ‹è·</p>
                            <p v-else-if="distancePoints.length === 1">ç‚¹å‡»åœ°å›¾æ·»åŠ ç¬¬äºŒä¸ªç‚¹</p>
                            <p v-else>æ€»è·ç¦»: <strong>{{ totalDistance.toFixed(2) }} ç±³</strong></p>
                            <el-button
                                v-if="distancePoints.length > 0"
                                size="mini"
                                type="danger"
                                @click="clearDistance"
                            >
                                æ¸…é™¤æµ‹è·
                            </el-button>
                        </div>
                    </el-form>
                    <div class="info-text">
                        <p>ğŸ’¡ æç¤ºï¼š</p>
                        <p>â€¢ è¾“å…¥åœ°å€åç‚¹å‡»æœç´¢æŒ‰é’®æˆ–æŒ‰å›è½¦é”®è¿›è¡Œåœ°å€æœç´¢</p>
                        <p>â€¢ ç‚¹å‡»"å®šä½åˆ°åæ ‡"æŒ‰é’®å¯ç›´æ¥å®šä½åˆ°æŒ‡å®šç»çº¬åº¦</p>
                        <p>â€¢ å•å‡»åœ°å›¾ä»»æ„ä½ç½®å¯æ·»åŠ æ ‡è®°ç‚¹å¹¶è‡ªåŠ¨æ›´æ–°åæ ‡</p>
                        <p>â€¢ æ”¯æŒå›è½¦é”®å¿«é€Ÿå®šä½</p>
                        <p>â€¢ ç‚¹å‡»"åŠ è½½3Dæ¨¡å‹"åœ¨å½“å‰åæ ‡åŠ è½½GLBæ¨¡å‹</p>
                        <p>â€¢ å½“å‰ä½¿ç”¨OpenStreetMapï¼ˆå…è´¹å¼€æºåœ°å›¾ï¼‰</p>
                    </div>
                </div>

                <!-- 3Dæ¨¡å‹æ§åˆ¶é¢æ¿ -->
                <div class="model-controls" v-if="models.length > 0">
                    <h4>3Dæ¨¡å‹åˆ—è¡¨</h4>
                    <div v-for="(model, index) in models" :key="index" style="margin-bottom: 10px">
                        <p>æ¨¡å‹ {{index + 1}}: {{model.lat.toFixed(6)}}, {{model.lng.toFixed(6)}}</p>
                        <el-button size="mini" type="danger" @click="removeModel(index)">åˆ é™¤</el-button>
                    </div>
                    <el-button size="small" type="warning" @click="clearAllModels">æ¸…é™¤æ‰€æœ‰æ¨¡å‹</el-button>
                </div>

                <!-- åœ°å›¾å®¹å™¨ -->
                <div id="map-container"></div>

                <!-- 3Dæ¨¡å‹å®¹å™¨ -->
                <div id="model-container"></div>
            </div>
        </div>

        <script>
            new Vue({
                el: '#app',
                data() {
                    return {
                        form: {
                            lng: '101.6869',
                            lat: '3.1390',
                            address: '', // æ·»åŠ åœ°å€å­—æ®µ
                        },
                        loading: false,
                        modelLoading: false,
                        addressLoading: false, // æ·»åŠ åœ°å€æœç´¢åŠ è½½çŠ¶æ€
                        map: null,
                        markers: [],
                        isDragging: false,
                        lastClickTime: 0,
                        glbTemUrl: '/basicTemplate.glb',
                        // glbTemUrl:
                        //     'https://shanghai-house-model.oss-accelerate.aliyuncs.com/glb/%E5%BA%95%E5%9B%BE%E6%A8%A1%E7%89%88/f7bd1a90-33b7-42a0-acbe-966c6d70d7fe.glb?v=1754621712839',
                        // Three.jsç›¸å…³
                        scene: null,
                        camera: null,
                        renderer: null,
                        controls: null,
                        models: [],
                        modelMeshes: [],
                        loader: null,
                        checkTimer: null, // æ·»åŠ å®šæ—¶å™¨å¼•ç”¨
                        baseLayers: {}, // æ·»åŠ å›¾å±‚ç»„å¼•ç”¨
                        pixelToThreeJSRatio: 1, // 1åƒç´  = 1Three.jså•ä½
                        meterToPixelRatio: 1, // 1ç±³ = å¤šå°‘åƒç´ 
                        isMeasuring: false, // æ–°å¢æµ‹è·æ¨¡å¼çŠ¶æ€
                        distancePoints: [], // æ–°å¢æµ‹è·ç‚¹æ•°ç»„
                        totalDistance: 0, // æ–°å¢æ€»è·ç¦»
                        distanceMarkers: [], // æ–°å¢æµ‹è·æ ‡è®°ç‚¹
                        distanceLines: [], // æ–°å¢æµ‹è·çº¿æ¡
                        distanceLabels: [], // æ–°å¢è·ç¦»æ ‡ç­¾
                        polygonLoading: false, // æ–°å¢å¤šè¾¹å½¢åŠ è½½çŠ¶æ€
                        currentPolygon: null, // æ–°å¢å½“å‰å¤šè¾¹å½¢
                        mouseFollowLine: null, // æ–°å¢é¼ æ ‡è·Ÿéšçº¿æ¡
                        mouseFollowLabel: null, // æ–°å¢é¼ æ ‡è·Ÿéšæ ‡ç­¾
                    }
                },
                mounted() {
                    this.initMap()
                    this.initThreeJS()
                },
                beforeDestroy() {
                    // æ¸…ç†å®šæ—¶å™¨
                    if (this.checkTimer) {
                        clearTimeout(this.checkTimer)
                        this.checkTimer = null
                    }

                    // æ¸…ç†Three.jsèµ„æº
                    if (this.renderer) {
                        this.renderer.dispose()
                    }
                    if (this.scene) {
                        this.scene.clear()
                    }

                    // æ¸…ç†åœ°å›¾
                    if (this.map) {
                        this.map.remove()
                    }

                    // æ¸…ç†æµ‹è·èµ„æº
                    this.clearDistance()

                    // æ¸…ç†é¼ æ ‡è·Ÿéšå…ƒç´ 
                    this.clearMouseFollowElements()

                    // æ¸…ç†å¤šè¾¹å½¢èµ„æº
                    if (this.currentPolygon) {
                        this.map.removeLayer(this.currentPolygon)
                        this.currentPolygon = null
                    }
                },
                methods: {
                    // åˆå§‹åŒ–åœ°å›¾
                    initMap() {
                        // åˆ›å»ºLeafletåœ°å›¾å®ä¾‹
                        this.map = L.map('map-container', {
                            zoomControl: false, // ç¦ç”¨é»˜è®¤çš„ç¼©æ”¾æ§ä»¶
                        }).setView([parseFloat(this.form.lat), parseFloat(this.form.lng)], 12)

                        // æ·»åŠ æ¯”ä¾‹å°ºæ§ä»¶
                        L.control
                            .scale({
                                position: 'bottomleft',
                                maxWidth: 200,
                                metric: true,
                                imperial: false,
                                updateWhenIdle: true,
                            })
                            .addTo(this.map)

                        // åˆ›å»ºå›¾å±‚ç»„
                        this.baseLayers = {
                            OpenStreetMap: L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                                attribution: 'Â© OpenStreetMap contributors',
                                maxZoom: 19,
                            }),
                            å«æ˜Ÿå½±åƒ: L.tileLayer(
                                'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
                                {
                                    attribution: 'Â© Esri',
                                    maxZoom: 19,
                                }
                            ),
                            åœ°å½¢å›¾: L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
                                attribution: 'Â© OpenTopoMap',
                                maxZoom: 17,
                            }),
                            è¡—é“å›¾: L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                                attribution: 'Â© OpenStreetMap contributors',
                                maxZoom: 19,
                            }),
                        }

                        // æ·»åŠ å›¾å±‚æ§ä»¶
                        L.control
                            .layers(this.baseLayers, null, {
                                position: 'topright',
                                collapsed: false,
                            })
                            .addTo(this.map)

                        // æ·»åŠ ç¼©æ”¾å±‚çº§æ§ä»¶
                        L.control
                            .zoom({
                                position: 'bottomright',
                                zoomInTitle: 'æ”¾å¤§',
                                zoomOutTitle: 'ç¼©å°',
                            })
                            .addTo(this.map)

                        // æ·»åŠ ç¼©æ”¾çº§åˆ«æ˜¾ç¤ºæ§ä»¶
                        L.Control.ZoomLevel = L.Control.extend({
                            onAdd: function (map) {
                                const container = L.DomUtil.create('div', 'leaflet-control-zoomlevel')
                                container.innerHTML = `
                                    <div style="
                                        background: white;
                                        padding: 5px 10px;
                                        border: 2px solid rgba(0,0,0,0.2);
                                        border-radius: 4px;
                                        font-size: 12px;
                                        font-weight: bold;
                                        color: #333;
                                        min-width: 40px;
                                        text-align: center;
                                    ">
                                        å±‚çº§ï¼š<span id="zoom-level">${map.getZoom()}</span>
                                    </div>
                                `

                                // ç›‘å¬ç¼©æ”¾äº‹ä»¶
                                map.on('zoomend', function () {
                                    document.getElementById('zoom-level').textContent = map.getZoom()
                                })

                                return container
                            },
                        })

                        // æ·»åŠ ç¼©æ”¾çº§åˆ«æ§ä»¶åˆ°åœ°å›¾
                        new L.Control.ZoomLevel({
                            position: 'bottomright',
                        }).addTo(this.map)

                        // é»˜è®¤æ˜¾ç¤ºOpenStreetMapå›¾å±‚
                        this.baseLayers['OpenStreetMap'].addTo(this.map)

                        // ç›‘å¬åœ°å›¾ç‚¹å‡»äº‹ä»¶
                        this.map.on('click', this.handleMapClick)

                        // ç›‘å¬åœ°å›¾æ‹–æ‹½äº‹ä»¶
                        this.map.on('dragstart', this.handleDragStart)
                        this.map.on('dragend', this.handleDragEnd)

                        // ç›‘å¬åœ°å›¾ç¼©æ”¾å’Œç§»åŠ¨äº‹ä»¶ï¼Œæ›´æ–°3Dæ¨¡å‹ä½ç½®
                        this.map.on('zoomend moveend', this.updateModelsPosition)

                        // ç›‘å¬åœ°å›¾è§†å›¾å˜åŒ–äº‹ä»¶
                        this.map.on('viewreset', this.updateModelsPosition)

                        // ç›‘å¬é¼ æ ‡ç§»åŠ¨äº‹ä»¶ï¼Œç”¨äºæµ‹è·é¢„è§ˆ
                        this.map.on('mousemove', this.handleMouseMove)
                    },

                    // åˆå§‹åŒ–Three.js
                    initThreeJS() {
                        // ç­‰å¾…Three.jsæ¨¡å—åŠ è½½å®Œæˆ
                        let checkCount = 0
                        const maxChecks = 50 // æœ€å¤§æ£€æŸ¥æ¬¡æ•°ï¼ˆ10ç§’ï¼‰
                        let checkTimer = null

                        const checkModules = () => {
                            checkCount++

                            // è¶…æ—¶æ£€æŸ¥
                            if (checkCount > maxChecks) {
                                console.error('Three.jsæ¨¡å—åŠ è½½è¶…æ—¶')
                                this.$message.error('3Då¼•æ“åŠ è½½è¶…æ—¶ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•')
                                return
                            }

                            if (typeof THREE !== 'undefined') {
                                // æ£€æŸ¥GLTFLoaderå’ŒOrbitControlsæ˜¯å¦å¯ç”¨
                                let gltfLoaderAvailable = false
                                let orbitControlsAvailable = false

                                // æ£€æŸ¥GLTFLoader
                                if (typeof THREE.GLTFLoader !== 'undefined') {
                                    gltfLoaderAvailable = true
                                } else if (typeof window.GLTFLoader !== 'undefined') {
                                    THREE.GLTFLoader = window.GLTFLoader
                                    gltfLoaderAvailable = true
                                } else {
                                    // å°è¯•ä»å…¨å±€å˜é‡ä¸­æŸ¥æ‰¾
                                    if (window.THREE && window.THREE.GLTFLoader) {
                                        THREE.GLTFLoader = window.THREE.GLTFLoader
                                        gltfLoaderAvailable = true
                                    }
                                }

                                // æ£€æŸ¥OrbitControls
                                if (typeof THREE.OrbitControls !== 'undefined') {
                                    orbitControlsAvailable = true
                                } else if (typeof window.OrbitControls !== 'undefined') {
                                    THREE.OrbitControls = window.OrbitControls
                                    orbitControlsAvailable = true
                                } else {
                                    // å°è¯•ä»å…¨å±€å˜é‡ä¸­æŸ¥æ‰¾
                                    if (window.THREE && window.THREE.OrbitControls) {
                                        THREE.OrbitControls = window.THREE.OrbitControls
                                        orbitControlsAvailable = true
                                    }
                                }

                                if (gltfLoaderAvailable) {
                                    // æ¸…ç†å®šæ—¶å™¨
                                    if (checkTimer) {
                                        clearTimeout(checkTimer)
                                        checkTimer = null
                                    }
                                    console.log('Three.jsæ¨¡å—åŠ è½½å®Œæˆ')
                                    this.setupThreeJS()
                                } else {
                                    // ç»§ç»­æ£€æŸ¥
                                    checkTimer = setTimeout(checkModules, 200)
                                }
                            } else {
                                // ç»§ç»­æ£€æŸ¥
                                checkTimer = setTimeout(checkModules, 200)
                            }
                        }

                        // å¼€å§‹æ£€æŸ¥
                        checkModules()

                        // ä¿å­˜å®šæ—¶å™¨å¼•ç”¨ï¼Œä»¥ä¾¿åœ¨ç»„ä»¶é”€æ¯æ—¶æ¸…ç†
                        this.checkTimer = checkTimer
                    },

                    // è®¾ç½®Three.js
                    setupThreeJS() {
                        // æ£€æŸ¥THREEå¯¹è±¡æ˜¯å¦å¯ç”¨
                        if (typeof THREE === 'undefined') {
                            console.error('THREE.js not loaded yet')
                            return
                        }

                        const container = document.getElementById('model-container')

                        // åˆ›å»ºåœºæ™¯
                        this.scene = new THREE.Scene()
                        // è®¾ç½®åœºæ™¯èƒŒæ™¯ä¸ºé€æ˜
                        this.scene.background = null
                        this.scene.fog = null // ç§»é™¤é›¾æ•ˆ

                        // åˆ›å»ºç›¸æœº
                        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000)
                        this.camera.position.set(0, 10, 10)

                        // åˆ›å»ºæ¸²æŸ“å™¨ - ç¡®ä¿é€æ˜èƒŒæ™¯
                        this.renderer = new THREE.WebGLRenderer({
                            alpha: true,
                            antialias: true,
                            preserveDrawingBuffer: false,
                            premultipliedAlpha: false,
                        })
                        this.renderer.setSize(window.innerWidth, window.innerHeight)
                        this.renderer.setClearColor(0x000000, 0) // è®¾ç½®é€æ˜èƒŒæ™¯
                        this.renderer.outputEncoding = THREE.sRGBEncoding
                        this.renderer.autoClear = false // ç¦ç”¨è‡ªåŠ¨æ¸…é™¤
                        this.renderer.sortObjects = false // ç¦ç”¨å¯¹è±¡æ’åº
                        this.renderer.setViewport(0, 0, window.innerWidth, window.innerHeight)
                        container.appendChild(this.renderer.domElement)

                        // åˆ›å»ºæ§åˆ¶å™¨ - ç¦ç”¨OrbitControlsï¼Œå› ä¸ºæˆ‘ä»¬è¦ä¸åœ°å›¾ç»‘å®š
                        // this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement)
                        // this.controls.enableDamping = true
                        // this.controls.dampingFactor = 0.05

                        // åˆ›å»ºGLTFåŠ è½½å™¨
                        try {
                            if (typeof THREE.GLTFLoader !== 'undefined') {
                                this.loader = new THREE.GLTFLoader()
                            } else if (typeof window.GLTFLoader !== 'undefined') {
                                this.loader = new window.GLTFLoader()
                            } else {
                                console.error('GLTFLoader not available')
                                this.loader = null
                            }
                        } catch (error) {
                            console.error('Failed to create GLTFLoader:', error)
                            this.loader = null
                        }

                        // æ·»åŠ å…‰æº
                        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6)
                        this.scene.add(ambientLight)

                        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8)
                        directionalLight.position.set(10, 10, 5)
                        this.scene.add(directionalLight)

                        // å¼€å§‹æ¸²æŸ“å¾ªç¯
                        this.animate()

                        // ç›‘å¬çª—å£å¤§å°å˜åŒ–
                        window.addEventListener('resize', this.onWindowResize)
                    },

                    // æ¸²æŸ“å¾ªç¯
                    animate() {
                        if (this.scene && this.camera && this.renderer) {
                            requestAnimationFrame(this.animate)
                            // æ›´æ–°ç›¸æœºä½ç½®ä»¥åŒ¹é…åœ°å›¾
                            this.updateCameraToMap()
                            // æ¸…é™¤èƒŒæ™¯å¹¶æ¸²æŸ“
                            this.renderer.clear(true, true, false) // æ¸…é™¤é¢œè‰²å’Œæ·±åº¦ç¼“å†²ï¼Œä¸æ¸…é™¤æ¨¡æ¿ç¼“å†²
                            this.renderer.render(this.scene, this.camera)
                        }
                    },

                    // æ›´æ–°ç›¸æœºä½ç½®ä»¥åŒ¹é…åœ°å›¾
                    updateCameraToMap() {
                        if (!this.map || !this.camera) return

                        const center = this.map.getCenter()
                        const zoom = this.map.getZoom()
                        const bounds = this.map.getBounds()

                        // è®¡ç®—åœ°å›¾çš„åƒç´ å°ºå¯¸
                        const mapSize = this.map.getSize()

                        // ä½¿ç”¨Leafletå†…ç½®æ–¹æ³•è®¡ç®—1ç±³å¯¹åº”çš„åƒç´ è·ç¦»
                        const centerPoint = this.map.latLngToContainerPoint(center)
                        const southPoint = this.map.latLngToContainerPoint([
                            center.lat - 0.00001, // å‘å—ç§»åŠ¨ä¸€å°æ®µè·ç¦»
                            center.lng,
                        ])
                        const pixelDistance1Meter = Math.abs(southPoint.y - centerPoint.y) * 100000 // è½¬æ¢ä¸º1ç±³å¯¹åº”çš„åƒç´ 

                        // è®¾ç½®ç›¸æœºä½ç½®å’Œè§†è§’
                        const aspect = window.innerWidth / window.innerHeight
                        const fov = 75
                        const distance =
                            (Math.max(mapSize.x, mapSize.y) / (2 * Math.tan((fov * Math.PI) / 180 / 2))) * 0.5

                        this.camera.position.set(0, distance, 0)
                        this.camera.lookAt(0, 0, 0)
                        this.camera.fov = fov
                        this.camera.aspect = aspect
                        this.camera.updateProjectionMatrix()

                        // ä¿å­˜åƒç´ åˆ°Three.jsçš„æ¯”ä¾‹å…³ç³»
                        this.pixelToThreeJSRatio = 1 // 1åƒç´  = 1Three.jså•ä½
                        this.meterToPixelRatio = pixelDistance1Meter // 1ç±³ = å¤šå°‘åƒç´ 
                    },

                    // å°†ç»çº¬åº¦è½¬æ¢ä¸ºThree.jsåæ ‡ï¼ˆä¸åœ°å›¾ç»‘å®šï¼‰
                    latLngToThreeJSPosition(lng, lat) {
                        // æ£€æŸ¥THREEå¯¹è±¡æ˜¯å¦å¯ç”¨
                        if (typeof THREE === 'undefined') {
                            console.error('THREE.js not loaded yet')
                            return { x: 0, y: 0, z: 0 }
                        }

                        if (!this.map) {
                            return new THREE.Vector3(0, 0, 0)
                        }

                        // è·å–åœ°å›¾ä¸­å¿ƒç‚¹
                        const center = this.map.getCenter()

                        // ä½¿ç”¨Leafletå†…ç½®æ–¹æ³•å°†ç»çº¬åº¦è½¬æ¢ä¸ºåƒç´ åæ ‡
                        const point = this.map.latLngToContainerPoint([lat, lng])
                        const centerPoint = this.map.latLngToContainerPoint([center.lat, center.lng])

                        // è®¡ç®—ç›¸å¯¹äºåœ°å›¾ä¸­å¿ƒçš„åƒç´ åç§»
                        const offsetX = point.x - centerPoint.x
                        const offsetY = point.y - centerPoint.y

                        // è½¬æ¢ä¸ºThree.jsåæ ‡ç³»ç»Ÿ
                        // ä½¿ç”¨åƒç´ åæ ‡ç›´æ¥æ˜ å°„åˆ°Three.jsåæ ‡ï¼Œç¡®ä¿1åƒç´ =1Three.jså•ä½
                        const x = offsetX
                        const z = -offsetY // æ³¨æ„zè½´æ–¹å‘
                        const y = 0 // åœ°é¢é«˜åº¦

                        return new THREE.Vector3(x, y, z)
                    },

                    // è®¡ç®—åœ°å›¾ä¸Š1ç±³å¯¹åº”çš„Three.jsåæ ‡å•ä½
                    calculateMeterToThreeJSUnit() {
                        if (!this.map) return 1

                        const center = this.map.getCenter()

                        // ä½¿ç”¨Leafletå†…ç½®æ–¹æ³•è®¡ç®—1ç±³å¯¹åº”çš„åƒç´ è·ç¦»
                        const centerPoint = this.map.latLngToContainerPoint(center)

                        // å‘å—1ç±³çš„ç‚¹ï¼ˆä½¿ç”¨ç»çº¬åº¦åç§»ï¼‰
                        const southLat = center.lat - 1 / 111320 // å¤§çº¦1ç±³å¯¹åº”çš„çº¬åº¦å˜åŒ–
                        const southPoint = this.map.latLngToContainerPoint([southLat, center.lng])
                        const pixelDistance1Meter = Math.abs(southPoint.y - centerPoint.y)

                        // é˜²æ­¢è¿”å›0æˆ–æ— æ•ˆå€¼
                        if (pixelDistance1Meter <= 0 || isNaN(pixelDistance1Meter)) {
                            console.warn('Invalid pixel distance for 1 meter, using default value')
                            return 1
                        }

                        // ç”±äº1åƒç´ =1Three.jså•ä½ï¼Œæ‰€ä»¥1ç±³å¯¹åº”çš„Three.jså•ä½å°±æ˜¯åƒç´ è·ç¦»
                        return pixelDistance1Meter
                    },

                    // åŸºäºçœŸå®åœ°ç†è·ç¦»è®¡ç®—æ¨¡å‹ç¼©æ”¾
                    calculateScaleFromRealDistance(lng, lat) {
                        if (!this.map) return 1

                        const center = this.map.getCenter()

                        // ä½¿ç”¨Leafletå†…ç½®æ–¹æ³•è®¡ç®—è·ç¦»
                        const modelPoint = this.map.latLngToContainerPoint([lat, lng])
                        const centerPoint = this.map.latLngToContainerPoint([center.lat, center.lng])

                        // è®¡ç®—åƒç´ è·ç¦»
                        const pixelDistance = Math.sqrt(
                            Math.pow(modelPoint.x - centerPoint.x, 2) + Math.pow(modelPoint.y - centerPoint.y, 2)
                        )

                        // è½¬æ¢ä¸ºç±³ï¼ˆä½¿ç”¨1ç±³å¯¹åº”çš„åƒç´ è·ç¦»ï¼‰
                        const meterToPixel = this.calculateMeterToThreeJSUnit()

                        // é˜²æ­¢é™¤é›¶é”™è¯¯
                        let distanceFromCenter = 0
                        if (meterToPixel > 0 && !isNaN(meterToPixel)) {
                            distanceFromCenter = pixelDistance / meterToPixel
                        } else {
                            console.warn('Invalid meterToPixel value, using 0 for distanceFromCenter')
                            distanceFromCenter = 0
                        }

                        // è·å–1ç±³å¯¹åº”çš„Three.jså•ä½
                        const meterToUnit = this.calculateMeterToThreeJSUnit()

                        // åŸºç¡€ç¼©æ”¾å› å­ï¼ˆæ ¹æ®åœ°å›¾ç¼©æ”¾çº§åˆ«ï¼‰
                        const zoom = this.map.getZoom()
                        const baseScale = Math.pow(2, zoom - 10) * 0.5

                        // è·ç¦»å› å­ï¼šè·ç¦»ä¸­å¿ƒè¶Šè¿œï¼Œç¼©æ”¾è¶Šå°
                        const maxDistance = 1000 // æœ€å¤§è·ç¦»é˜ˆå€¼ï¼ˆç±³ï¼‰
                        const distanceFactor = Math.exp(-distanceFromCenter / maxDistance)

                        // ç¡®ä¿æœ€å°ç¼©æ”¾æ¯”ä¾‹
                        const minScale = 0.01
                        const finalScale = Math.max(minScale, baseScale * distanceFactor * meterToUnit)
                        return finalScale
                    },
                    // æ›´æ–°æ‰€æœ‰æ¨¡å‹çš„ä½ç½®ï¼ˆå½“åœ°å›¾ç§»åŠ¨æˆ–ç¼©æ”¾æ—¶ï¼‰
                    updateModelsPosition() {
                        if (!this.models.length) return

                        this.models.forEach((modelInfo, index) => {
                            const newPosition = this.latLngToThreeJSPosition(modelInfo.lng, modelInfo.lat)
                            if (modelInfo.model) {
                                // æ›´æ–°ä½ç½®
                                modelInfo.model.position.copy(newPosition)

                                // åŸºäºç»çº¬åº¦ä¸­å¿ƒç‚¹æ›´æ–°å¤§å°
                                if (modelInfo.originalScale) {
                                    const newScale =
                                        this.calculateScaleFromRealDistance(modelInfo.lng, modelInfo.lat) *
                                        modelInfo.originalScale
                                    modelInfo.model.scale.setScalar(newScale)
                                }
                            }
                        })
                    },

                    // æœç´¢åœ°å€å¹¶è‡ªåŠ¨å®šä½
                    searchAddress() {
                        if (!this.form.address.trim()) {
                            this.$message.warning('è¯·è¾“å…¥è¦æœç´¢çš„åœ°å€')
                            return
                        }

                        this.addressLoading = true

                        // ä½¿ç”¨Nominatimåœ°ç†ç¼–ç æœåŠ¡
                        const searchUrl = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(
                            this.form.address
                        )}&limit=1`

                        fetch(searchUrl)
                            .then((response) => response.json())
                            .then((data) => {
                                this.addressLoading = false

                                if (data && data.length > 0) {
                                    const result = data[0]
                                    const lat = parseFloat(result.lat)
                                    const lng = parseFloat(result.lon)

                                    // æ›´æ–°è¡¨å•ä¸­çš„åæ ‡
                                    this.form.lat = lat.toFixed(6)
                                    this.form.lng = lng.toFixed(6)

                                    // å®šä½åˆ°æœç´¢åˆ°çš„ä½ç½®
                                    this.map.setView([lat, lng], 17)

                                    // æ·»åŠ æ ‡è®°ç‚¹
                                    this.addMarker(lng, lat)

                                    const timer = setTimeout(() => {
                                        clearTimeout(timer)
                                        this.$message({
                                            message: `å·²å®šä½åˆ°ï¼š${result.display_name}`,
                                            type: 'success',
                                            duration: 3000,
                                        })
                                    }, 800)
                                } else {
                                    this.$message.error('æœªæ‰¾åˆ°è¯¥åœ°å€ï¼Œè¯·æ£€æŸ¥åœ°å€æ˜¯å¦æ­£ç¡®')
                                }
                            })
                            .catch((error) => {
                                this.addressLoading = false
                                console.error('åœ°å€æœç´¢å¤±è´¥:', error)
                                this.$message.error('åœ°å€æœç´¢å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥')
                            })
                    },

                    // ä¿®æ­£åæ ‡èŒƒå›´
                    normalizeCoordinate(lng, lat) {
                        // å¤„ç†ç»åº¦èŒƒå›´
                        let normalizedLng = lng
                        while (normalizedLng < -180) {
                            normalizedLng += 360
                        }
                        while (normalizedLng > 180) {
                            normalizedLng -= 360
                        }

                        // å¤„ç†çº¬åº¦èŒƒå›´
                        let normalizedLat = lat
                        if (normalizedLat < -90) {
                            normalizedLat = -90
                        }
                        if (normalizedLat > 90) {
                            normalizedLat = 90
                        }

                        return { lng: normalizedLng, lat: normalizedLat }
                    },

                    // å¤„ç†åœ°å›¾ç‚¹å‡»äº‹ä»¶
                    handleMapClick(e) {
                        console.log('ç‚¹å‡»äº‹ä»¶å¯¹è±¡:', e)
                        console.log('åŸå§‹åæ ‡:', e.latlng)
                        console.log('åœ°å›¾ä¸­å¿ƒ:', this.map.getCenter())
                        console.log('åœ°å›¾ç¼©æ”¾çº§åˆ«:', this.map.getZoom())
                        console.log('åœ°å›¾è¾¹ç•Œ:', this.map.getBounds())

                        // æ£€æŸ¥æ˜¯å¦ä¸ºæ‹–æ‹½ç»“æŸåçš„ç‚¹å‡»
                        const now = Date.now()
                        if (now - this.lastClickTime < 200) {
                            return // å¿½ç•¥æ‹–æ‹½ç»“æŸåçš„ç‚¹å‡»
                        }

                        let lat = e.latlng.lat
                        let lng = e.latlng.lng

                        // ä¿®æ­£åæ ‡èŒƒå›´
                        const normalized = this.normalizeCoordinate(lng, lat)
                        lng = normalized.lng
                        lat = normalized.lat

                        console.log('ä¿®æ­£åçš„åæ ‡:', { lng, lat })

                        // å¦‚æœåœ¨æµ‹è·æ¨¡å¼ä¸‹ï¼Œå¤„ç†æµ‹è·ç‚¹å‡»
                        if (this.isMeasuring) {
                            this.handleDistanceClick(lng, lat)
                            return
                        }

                        // æ›´æ–°è¡¨å•ä¸­çš„ç»çº¬åº¦
                        this.form.lng = lng.toFixed(6)
                        this.form.lat = lat.toFixed(6)

                        // æ·»åŠ æ ‡è®°ç‚¹
                        this.addMarker(lng, lat)
                    },

                    // å¤„ç†æ‹–æ‹½å¼€å§‹
                    handleDragStart() {
                        this.isDragging = true
                    },

                    // å¤„ç†æ‹–æ‹½ç»“æŸ
                    handleDragEnd() {
                        this.isDragging = false
                        this.lastClickTime = Date.now()
                    },

                    // æ·»åŠ æ ‡è®°ç‚¹
                    addMarker(lng, lat) {
                        // æ¸…é™¤ä¹‹å‰çš„æ ‡è®°ç‚¹
                        this.clearMarkers()

                        // åˆ›å»ºæ–°çš„æ ‡è®°ç‚¹
                        const marker = L.marker([lat, lng]).addTo(this.map)

                        // æ·»åŠ å¼¹å‡ºä¿¡æ¯
                        marker.bindPopup(`ç»åº¦: ${lng.toFixed(6)}, çº¬åº¦: ${lat.toFixed(6)}`)

                        // å°†æ ‡è®°ç‚¹æ·»åŠ åˆ°æ•°ç»„
                        this.markers.push(marker)

                        // æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
                        this.$message({
                            message: `å·²æ·»åŠ æ ‡è®°ç‚¹ï¼šç»åº¦ ${lng.toFixed(6)}ï¼Œçº¬åº¦ ${lat.toFixed(6)}`,
                            type: 'success',
                            duration: 2000,
                        })
                    },

                    // æ¸…é™¤æ‰€æœ‰æ ‡è®°ç‚¹
                    clearMarkers() {
                        this.markers.forEach((marker) => {
                            this.map.removeLayer(marker)
                        })
                        this.markers = []
                    },

                    // å®šä½åˆ°æŒ‡å®šåæ ‡
                    locateToCoordinates() {
                        const lng = parseFloat(this.form.lng)
                        const lat = parseFloat(this.form.lat)

                        // éªŒè¯è¾“å…¥
                        if (isNaN(lng) || isNaN(lat)) {
                            this.$message.error('è¯·è¾“å…¥æœ‰æ•ˆçš„ç»çº¬åº¦åæ ‡')
                            return
                        }

                        if (lng < -180 || lng > 180) {
                            this.$message.error('ç»åº¦èŒƒå›´åº”åœ¨ -180 åˆ° 180 ä¹‹é—´')
                            return
                        }

                        if (lat < -90 || lat > 90) {
                            this.$message.error('çº¬åº¦èŒƒå›´åº”åœ¨ -90 åˆ° 90 ä¹‹é—´')
                            return
                        }

                        this.loading = true

                        // è®¾ç½®åœ°å›¾ä¸­å¿ƒç‚¹
                        this.map.setView([lat, lng], 17)

                        // æ·»åŠ æ ‡è®°ç‚¹
                        this.addMarker(lng, lat)

                        this.loading = false
                    },

                    // åœ¨å½“å‰åæ ‡åŠ è½½3Dæ¨¡å‹
                    loadModelAtCurrentPosition() {
                        const lng = parseFloat(this.form.lng)
                        const lat = parseFloat(this.form.lat)

                        if (isNaN(lng) || isNaN(lat)) {
                            this.$message.error('è¯·å…ˆé€‰æ‹©æœ‰æ•ˆçš„åæ ‡ä½ç½®')
                            return
                        }

                        this.loadModel(lng, lat)
                    },

                    // åŠ è½½3Dæ¨¡å‹
                    loadModel(lng, lat) {
                        // æ£€æŸ¥THREEå¯¹è±¡æ˜¯å¦å¯ç”¨
                        if (typeof THREE === 'undefined') {
                            this.$message.error('3Då¼•æ“æœªåŠ è½½å®Œæˆï¼Œè¯·ç¨åå†è¯•')
                            return
                        }

                        // æ£€æŸ¥loaderæ˜¯å¦å¯ç”¨
                        if (!this.loader) {
                            this.$message.error('3Dæ¨¡å‹åŠ è½½å™¨æœªåˆå§‹åŒ–ï¼Œè¯·ç¨åå†è¯•')
                            return
                        }

                        this.modelLoading = true

                        // å°†ç»çº¬åº¦è½¬æ¢ä¸ºThree.jsåæ ‡
                        const position = this.latLngToThreeJSPosition(lng, lat)

                        this.loader.load(
                            this.glbTemUrl,
                            (gltf) => {
                                const model = gltf.scene

                                // è®¾ç½®æ¨¡å‹ä½ç½®
                                model.position.copy(position)

                                // è°ƒæ•´æ¨¡å‹å¤§å° - åŸºäºçœŸå®åœ°ç†è·ç¦»
                                const box = new THREE.Box3().setFromObject(model)
                                const size = box.getSize(new THREE.Vector3())
                                const maxDim = Math.max(size.x, size.y, size.z)

                                // åŸºäºçœŸå®åœ°ç†è·ç¦»è®¡ç®—ç¼©æ”¾
                                const scaleFactor = this.calculateScaleFromRealDistance(lng, lat)
                                // ç¡®ä¿æ¨¡å‹åœ¨scale=1æ—¶ï¼Œ1ç±³å¯¹åº”1ç±³
                                const scale = scaleFactor / maxDim
                                model.scale.setScalar(scale)

                                // æ·»åŠ åˆ°åœºæ™¯
                                this.scene.add(model)

                                // ä¿å­˜æ¨¡å‹ä¿¡æ¯ï¼ŒåŒ…æ‹¬åŸå§‹ç¼©æ”¾æ¯”ä¾‹
                                this.models.push({
                                    lng,
                                    lat,
                                    model,
                                    originalScale: scale / scaleFactor, // ä¿å­˜åŸºç¡€ç¼©æ”¾æ¯”ä¾‹
                                })
                                this.modelMeshes.push(model)

                                this.modelLoading = false
                                this.$message({
                                    message: `3Dæ¨¡å‹å·²åŠ è½½åˆ°åæ ‡ï¼š${lng.toFixed(6)}, ${lat.toFixed(6)}`,
                                    type: 'success',
                                    duration: 2000,
                                })
                            },
                            (progress) => {
                                console.log('åŠ è½½è¿›åº¦:', (progress.loaded / progress.total) * 100 + '%')
                            },
                            (error) => {
                                console.error('åŠ è½½æ¨¡å‹å¤±è´¥:', error)
                                this.modelLoading = false
                                this.$message.error('åŠ è½½3Dæ¨¡å‹å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–æ¨¡å‹URL')
                            }
                        )
                    },

                    // åˆ é™¤æŒ‡å®šæ¨¡å‹
                    removeModel(index) {
                        if (index >= 0 && index < this.models.length && this.scene) {
                            const model = this.models[index].model
                            this.scene.remove(model)
                            this.models.splice(index, 1)
                            this.modelMeshes.splice(index, 1)

                            this.$message({
                                message: 'æ¨¡å‹å·²åˆ é™¤',
                                type: 'success',
                                duration: 1500,
                            })
                        }
                    },

                    // æ¸…é™¤æ‰€æœ‰æ¨¡å‹
                    clearAllModels() {
                        if (this.scene) {
                            this.models.forEach((item) => {
                                this.scene.remove(item.model)
                            })
                            this.models = []
                            this.modelMeshes = []

                            this.$message({
                                message: 'æ‰€æœ‰æ¨¡å‹å·²æ¸…é™¤',
                                type: 'success',
                                duration: 1500,
                            })
                        }
                    },

                    // çª—å£å¤§å°å˜åŒ–å¤„ç†
                    onWindowResize() {
                        if (this.camera && this.renderer) {
                            this.camera.aspect = window.innerWidth / window.innerHeight
                            this.camera.updateProjectionMatrix()
                            this.renderer.setSize(window.innerWidth, window.innerHeight)
                        }
                    },

                    // åˆ‡æ¢æµ‹è·æ¨¡å¼
                    toggleMeasuring() {
                        this.isMeasuring = !this.isMeasuring
                        if (!this.isMeasuring) {
                            this.clearDistance()
                        }
                        this.$message({
                            message: this.isMeasuring ? 'å·²è¿›å…¥æµ‹è·æ¨¡å¼ï¼Œç‚¹å‡»åœ°å›¾æ·»åŠ æµ‹è·ç‚¹' : 'å·²é€€å‡ºæµ‹è·æ¨¡å¼',
                            type: this.isMeasuring ? 'success' : 'info',
                            duration: 2000,
                        })
                    },

                    // å¤„ç†æµ‹è·ç‚¹å‡»
                    handleDistanceClick(lng, lat) {
                        // æ·»åŠ æµ‹è·ç‚¹
                        this.distancePoints.push({ lng, lat })

                        // åˆ›å»ºæµ‹è·æ ‡è®°ç‚¹
                        const marker = L.circleMarker([lat, lng], {
                            radius: 6,
                            fillColor: '#409eff',
                            color: 'white',
                            weight: 2,
                            opacity: 1,
                            fillOpacity: 0.8,
                        }).addTo(this.map)

                        // æ·»åŠ æ ‡è®°ç‚¹ä¿¡æ¯
                        marker.bindPopup(`æµ‹è·ç‚¹ ${this.distancePoints.length}: ${lng.toFixed(6)}, ${lat.toFixed(6)}`)

                        this.distanceMarkers.push(marker)

                        // å¦‚æœæœ‰å¤šä¸ªç‚¹ï¼Œè®¡ç®—è·ç¦»å¹¶ç»˜åˆ¶çº¿æ¡
                        if (this.distancePoints.length >= 2) {
                            this.calculateAndDrawDistance()
                        }

                        this.$message({
                            message: `å·²æ·»åŠ æµ‹è·ç‚¹ ${this.distancePoints.length}`,
                            type: 'success',
                            duration: 1500,
                        })
                    },

                    // è®¡ç®—è·ç¦»å¹¶ç»˜åˆ¶çº¿æ¡
                    calculateAndDrawDistance() {
                        // æ¸…é™¤ä¹‹å‰çš„çº¿æ¡
                        this.clearDistanceLines()

                        // æ¸…é™¤é¼ æ ‡è·Ÿéšå…ƒç´ 
                        this.clearMouseFollowElements()

                        let totalDistance = 0

                        // è®¡ç®—æ‰€æœ‰ç‚¹ä¹‹é—´çš„è·ç¦»
                        for (let i = 0; i < this.distancePoints.length - 1; i++) {
                            const point1 = this.distancePoints[i]
                            const point2 = this.distancePoints[i + 1]

                            // ä½¿ç”¨turf.jsè®¡ç®—è·ç¦»
                            const from = turf.point([point1.lng, point1.lat])
                            const to = turf.point([point2.lng, point2.lat])
                            const distance = turf.distance(from, to) * 1000 // è½¬æ¢ä¸ºç±³

                            totalDistance += distance

                            // ç»˜åˆ¶çº¿æ¡
                            const line = L.polyline(
                                [
                                    [point1.lat, point1.lng],
                                    [point2.lat, point2.lng],
                                ],
                                {
                                    color: '#409eff',
                                    weight: 3,
                                    opacity: 0.8,
                                    dashArray: '5, 5',
                                }
                            ).addTo(this.map)

                            // åœ¨çº¿æ¡ä¸­é—´æ·»åŠ è·ç¦»æ ‡ç­¾
                            const midLat = (point1.lat + point2.lat) / 2
                            const midLng = (point1.lng + point2.lng) / 2

                            const distanceLabel = L.divIcon({
                                className: 'distance-label',
                                html: `<div style="
                                    background: white;
                                    border: 2px solid #409eff;
                                    border-radius: 4px;
                                    padding: 2px 6px;
                                    font-size: 11px;
                                    font-weight: bold;
                                    color: #409eff;
                                    white-space: nowrap;
                                    box-shadow: 0 1px 3px rgba(0,0,0,0.3);
                                    display: inline-block;
                                ">${distance.toFixed(1)}m</div>`,
                                iconSize: [1, 1],
                                iconAnchor: [0, 0],
                            })

                            const labelMarker = L.marker([midLat, midLng], { icon: distanceLabel }).addTo(this.map)
                            this.distanceLabels.push(labelMarker)

                            this.distanceLines.push(line)
                        }

                        this.totalDistance = totalDistance
                    },

                    // æ¸…é™¤æµ‹è·çº¿æ¡
                    clearDistanceLines() {
                        this.distanceLines.forEach((line) => {
                            this.map.removeLayer(line)
                        })
                        this.distanceLines = []
                    },

                    // æ¸…é™¤æµ‹è·
                    clearDistance() {
                        // æ¸…é™¤æµ‹è·æ ‡è®°ç‚¹
                        this.distanceMarkers.forEach((marker) => {
                            this.map.removeLayer(marker)
                        })
                        this.distanceMarkers = []

                        // æ¸…é™¤æµ‹è·çº¿æ¡
                        this.clearDistanceLines()

                        // æ¸…é™¤è·ç¦»æ ‡ç­¾
                        this.distanceLabels.forEach((label) => {
                            this.map.removeLayer(label)
                        })
                        this.distanceLabels = []

                        // æ¸…é™¤é¼ æ ‡è·Ÿéšå…ƒç´ 
                        this.clearMouseFollowElements()

                        // æ¸…é™¤æ•°æ®
                        this.distancePoints = []
                        this.totalDistance = 0
                        this.isMeasuring = false
                    },

                    // å¤„ç†é¼ æ ‡ç§»åŠ¨
                    handleMouseMove(e) {
                        if (!this.isMeasuring || this.distancePoints.length === 0) {
                            return
                        }

                        const mouseLat = e.latlng.lat
                        const mouseLng = e.latlng.lng
                        const lastPoint = this.distancePoints[this.distancePoints.length - 1]

                        // æ¸…é™¤ä¹‹å‰çš„é¼ æ ‡è·Ÿéšå…ƒç´ 
                        this.clearMouseFollowElements()

                        // åˆ›å»ºé¼ æ ‡è·Ÿéšçº¿æ¡
                        this.mouseFollowLine = L.polyline(
                            [
                                [lastPoint.lat, lastPoint.lng],
                                [mouseLat, mouseLng],
                            ],
                            {
                                color: '#409eff',
                                weight: 2,
                                opacity: 0.6,
                                dashArray: '5, 5',
                            }
                        ).addTo(this.map)

                        // è®¡ç®—é¢„è§ˆè·ç¦»
                        const from = turf.point([lastPoint.lng, lastPoint.lat])
                        const to = turf.point([mouseLng, mouseLat])
                        const distance = turf.distance(from, to) * 1000 // è½¬æ¢ä¸ºç±³

                        // åˆ›å»ºé¢„è§ˆè·ç¦»æ ‡ç­¾
                        const midLat = (lastPoint.lat + mouseLat) / 2
                        const midLng = (lastPoint.lng + mouseLng) / 2

                        const previewLabel = L.divIcon({
                            className: 'distance-preview-label',
                            html: `<div style="
                                background: rgba(64, 158, 255, 0.9);
                                color: white;
                                border-radius: 4px;
                                padding: 2px 6px;
                                font-size: 11px;
                                font-weight: bold;
                                white-space: nowrap;
                                box-shadow: 0 1px 3px rgba(0,0,0,0.3);
                                display: inline-block;
                            ">${distance.toFixed(1)}m</div>`,
                            iconSize: [1, 1],
                            iconAnchor: [0, 0],
                        })

                        this.mouseFollowLabel = L.marker([midLat, midLng], { icon: previewLabel }).addTo(this.map)
                    },

                    // æ¸…é™¤é¼ æ ‡è·Ÿéšå…ƒç´ 
                    clearMouseFollowElements() {
                        if (this.mouseFollowLine) {
                            this.map.removeLayer(this.mouseFollowLine)
                            this.mouseFollowLine = null
                        }
                        if (this.mouseFollowLabel) {
                            this.map.removeLayer(this.mouseFollowLabel)
                            this.mouseFollowLabel = null
                        }
                    },

                    // åˆ›å»º188må¤šè¾¹å½¢åŒºåŸŸ
                    createPolygon() {
                        const lng = parseFloat(this.form.lng)
                        const lat = parseFloat(this.form.lat)

                        if (isNaN(lng) || isNaN(lat)) {
                            this.$message.error('è¯·å…ˆé€‰æ‹©æœ‰æ•ˆçš„åæ ‡ä½ç½®')
                            return
                        }

                        this.polygonLoading = true

                        try {
                            // æ¸…é™¤ä¹‹å‰çš„å¤šè¾¹å½¢
                            if (this.currentPolygon) {
                                this.map.removeLayer(this.currentPolygon)
                                this.currentPolygon = null
                            }

                            // è®¡ç®—188mæ­£æ–¹å½¢åŒºåŸŸçš„å››ä¸ªè§’ç‚¹åæ ‡
                            const polygonCoords = this.calculatePolygonCoordinates(lng, lat, 188)

                            // åˆ›å»ºå¤šè¾¹å½¢
                            this.currentPolygon = L.polygon(polygonCoords, {
                                fillColor: '#409eff',
                                color: '#409eff',
                                weight: 1,
                                opacity: 1,
                                fillOpacity: 0.2, // é€æ˜è“è‰²èƒŒæ™¯
                            }).addTo(this.map)

                            // æ·»åŠ å¤šè¾¹å½¢ä¿¡æ¯å¼¹çª—
                            this.currentPolygon.bindPopup(`
                                <div style="text-align: center;">
                                    <strong>188m Ã— 188m åŒºåŸŸ</strong><br>
                                    ä¸­å¿ƒç‚¹: ${lng.toFixed(6)}, ${lat.toFixed(6)}<br>
                                    å°ºå¯¸: 188m Ã— 188m
                                </div>
                            `)

                            this.polygonLoading = false
                            this.$message({
                                message: `å·²åˆ›å»º188måŒºåŸŸï¼Œä¸­å¿ƒç‚¹ï¼š${lng.toFixed(6)}, ${lat.toFixed(6)}`,
                                type: 'success',
                                duration: 3000,
                            })
                        } catch (error) {
                            this.polygonLoading = false
                            console.error('åˆ›å»ºå¤šè¾¹å½¢å¤±è´¥:', error)
                            this.$message.error('åˆ›å»ºå¤šè¾¹å½¢å¤±è´¥ï¼Œè¯·æ£€æŸ¥åæ ‡æ˜¯å¦æœ‰æ•ˆ')
                        }
                    },

                    // è®¡ç®—å¤šè¾¹å½¢åæ ‡
                    calculatePolygonCoordinates(centerLng, centerLat, sizeInMeters) {
                        // å°†ç±³è½¬æ¢ä¸ºåº¦ï¼ˆè¿‘ä¼¼è®¡ç®—ï¼‰
                        // 1åº¦çº¬åº¦çº¦ç­‰äº111,320ç±³
                        // 1åº¦ç»åº¦çº¦ç­‰äº111,320 * cos(çº¬åº¦)ç±³
                        const latDegreePerMeter = 1 / 111320
                        const lngDegreePerMeter = 1 / (111320 * Math.cos((centerLat * Math.PI) / 180))

                        // è®¡ç®—æ­£æ–¹å½¢åŒºåŸŸçš„åŠè¾¹é•¿ï¼ˆç±³è½¬åº¦ï¼‰
                        const halfSizeInDegrees = sizeInMeters / 2

                        // è®¡ç®—å››ä¸ªè§’ç‚¹çš„åæ ‡
                        const coordinates = [
                            // å·¦ä¸Šè§’
                            [
                                centerLat + halfSizeInDegrees * latDegreePerMeter,
                                centerLng - halfSizeInDegrees * lngDegreePerMeter,
                            ],
                            // å³ä¸Šè§’
                            [
                                centerLat + halfSizeInDegrees * latDegreePerMeter,
                                centerLng + halfSizeInDegrees * lngDegreePerMeter,
                            ],
                            // å³ä¸‹è§’
                            [
                                centerLat - halfSizeInDegrees * latDegreePerMeter,
                                centerLng + halfSizeInDegrees * lngDegreePerMeter,
                            ],
                            // å·¦ä¸‹è§’
                            [
                                centerLat - halfSizeInDegrees * latDegreePerMeter,
                                centerLng - halfSizeInDegrees * lngDegreePerMeter,
                            ],
                            // é—­åˆå¤šè¾¹å½¢
                            [
                                centerLat + halfSizeInDegrees * latDegreePerMeter,
                                centerLng - halfSizeInDegrees * lngDegreePerMeter,
                            ],
                        ]

                        return coordinates
                    },
                },
            })
        </script>
    </body>
</html>
